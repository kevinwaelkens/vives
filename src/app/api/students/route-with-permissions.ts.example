// Example: src/app/api/students/route.ts with permissions

import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { prisma } from '@/lib/prisma'
import { getCurrentUser } from '@/lib/auth/utils'
import { generateStudentId } from '@/lib/utils'
import { 
  requirePermission, 
  requireAnyPermission,
  PERMISSIONS 
} from '@/lib/permissions'

const CreateStudentSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email address'),
  groupId: z.string().cuid('Invalid group ID'),
  dateOfBirth: z.string().optional(),
  notes: z.string().optional(),
})

// GET /api/students - Get all students with filtering
export const GET = requirePermission(PERMISSIONS.STUDENTS_VIEW)(
  async function (req: NextRequest, { user }: { user: any }) {
    try {
      const searchParams = req.nextUrl.searchParams
      const groupId = searchParams.get('groupId')
      const status = searchParams.get('status')
      const search = searchParams.get('search')
      const page = parseInt(searchParams.get('page') || '1')
      const pageSize = parseInt(searchParams.get('pageSize') || '10')

      const where: any = {}

      if (groupId) {
        where.groupId = groupId
      }

      if (status) {
        where.status = status
      }

      if (search) {
        where.OR = [
          { name: { contains: search, mode: 'insensitive' } },
          { email: { contains: search, mode: 'insensitive' } },
          { studentId: { contains: search, mode: 'insensitive' } },
        ]
      }

      // If user is a tutor, only show students from their groups
      if (user.role === 'TUTOR') {
        const userGroups = await prisma.group.findMany({
          where: {
            tutors: {
              some: {
                id: user.id,
              },
            },
          },
          select: { id: true },
        })

        where.groupId = {
          in: userGroups.map(g => g.id),
        }
      }

      const [students, total] = await Promise.all([
        prisma.student.findMany({
          where,
          include: {
            group: {
              select: {
                id: true,
                name: true,
                code: true,
              },
            },
            _count: {
              select: {
                assessments: true,
                attendance: true,
              },
            },
          },
          skip: (page - 1) * pageSize,
          take: pageSize,
          orderBy: { name: 'asc' },
        }),
        prisma.student.count({ where }),
      ])

      return NextResponse.json({
        data: students,
        total,
        page,
        pageSize,
        totalPages: Math.ceil(total / pageSize),
      })
    } catch (error) {
      console.error('Error fetching students:', error)
      return NextResponse.json(
        { error: 'Failed to fetch students' },
        { status: 500 }
      )
    }
  }
)

// POST /api/students - Create a new student
export const POST = requirePermission(PERMISSIONS.STUDENTS_CREATE)(
  async function (req: NextRequest, { user }: { user: any }) {
    try {
      const body = await req.json()
      const validatedData = CreateStudentSchema.parse(body)

      // Check if user can access the specified group
      if (user.role === 'TUTOR') {
        const canAccessGroup = await prisma.group.findFirst({
          where: {
            id: validatedData.groupId,
            tutors: {
              some: {
                id: user.id,
              },
            },
          },
        })

        if (!canAccessGroup) {
          return NextResponse.json(
            { error: 'You do not have permission to add students to this group' },
            { status: 403 }
          )
        }
      }

      // Check if email already exists
      const existingStudent = await prisma.student.findUnique({
        where: { email: validatedData.email },
      })

      if (existingStudent) {
        return NextResponse.json(
          { error: 'Student with this email already exists' },
          { status: 400 }
        )
      }

      const student = await prisma.student.create({
        data: {
          ...validatedData,
          studentId: generateStudentId(),
          dateOfBirth: validatedData.dateOfBirth
            ? new Date(validatedData.dateOfBirth)
            : null,
        },
        include: {
          group: {
            select: {
              id: true,
              name: true,
              code: true,
            },
          },
        },
      })

      // Create audit log
      await prisma.auditLog.create({
        data: {
          action: 'CREATE',
          entity: 'Student',
          entityId: student.id,
          userId: user.id,
          newValues: {
            id: student.id,
            name: student.name,
            email: student.email,
            groupId: student.groupId,
          },
        },
      })

      return NextResponse.json({ data: student }, { status: 201 })
    } catch (error) {
      if (error instanceof z.ZodError) {
        return NextResponse.json(
          { error: 'Validation failed', details: error.issues },
          { status: 400 }
        )
      }

      console.error('Error creating student:', error)
      return NextResponse.json(
        { error: 'Failed to create student' },
        { status: 500 }
      )
    }
  }
)
